import * as zod from '../../dep/zod.ts';
import * as http from '../../dep/std/http.ts';
import * as pathToRegexp from '../../dep/path-to-regexp.ts';

import { LoaderContext } from './LoaderContext.ts';
import * as log from '../log/mod.ts';
import { FrugalError } from './FrugalError.ts';

function logger() {
    return log.getLogger('frugal:Page');
}

/**
 * The different phases of Frugal.
 *
 * A page descriptor method can be called in a build phase (during the Frugal
 * instance build), during the refresh phase (at runtime in a refresh call) or
 * during the generate phase (at runtime in a generate call).
 */
export type Phase = 'build' | 'refresh' | 'generate';

export type GetPathListParams = {
    /** The current phase (build, refresh or generate) */
    phase: Phase;
};

export type GetStaticDataContext<
    PATH extends Record<string, string> = Record<string, string>,
> = {
    /** The current phase (build, refresh or generate) */
    phase: Phase;
    /** The path for which we need the data */
    path: PATH;
};

export type GetDynamicDataContext<
    PATH extends Record<string, string> = Record<string, string>,
> = GetStaticDataContext<PATH> & {
    state: Record<string, unknown>;
};

export type GetContentParams<
    PATH extends Record<string, string> = Record<string, string>,
    DATA = unknown,
> = {
    /** the method of the request that caused the call to `getContent`  */
    method: string;

    /** The current phase (build, refresh or generate) */
    phase: Phase;

    /** The path object we need the content from */
    path: PATH;

    /** The data object we need the content from */
    data: DATA;

    /** The pathname of the page (the `pattern` of the descriptor compiled with the
     * path object) */
    pathname: string;

    /** The path of the descriptor */
    descriptor: string;

    /** The loader context (containing the assets generated by each loaders) */
    loaderContext: LoaderContext;
};

export type GetPathList<
    PATH extends Record<string, string> = Record<string, string>,
> = (
    params: GetPathListParams,
) => Promise<PATH[]> | PATH[];

export type NoDataResult = {
    status:
        | http.Status.MovedPermanently
        | http.Status.Found
        | http.Status.SeeOther
        | http.Status.TemporaryRedirect
        | http.Status.PermanentRedirect;
    location: URL | string;
    headers?: HeadersInit;
} | {
    status:
        | http.Status.Unauthorized
        | http.Status.PaymentRequired
        | http.Status.Forbidden
        | http.Status.NotFound
        | http.Status.RequestTimeout
        | http.Status.Conflict
        | http.Status.Gone
        | http.Status.Teapot
        | http.Status.TooManyRequests
        | http.Status.UnavailableForLegalReasons
        | http.Status.InternalServerError
        | http.Status.ServiceUnavailable;
    headers?: HeadersInit;
};

// deno-lint-ignore no-explicit-any
export type DataResult<DATA = any> =
    | { data?: DATA; headers?: HeadersInit }
    | NoDataResult;

export type GetStaticData<
    PATH extends Record<string, string> = Record<string, string>,
    DATA = unknown,
> = (
    context: GetStaticDataContext<PATH>,
) => Promise<DataResult<DATA>> | DataResult<DATA>;

export type GetDynamicData<
    PATH extends Record<string, string> = Record<string, string>,
    DATA = unknown,
> = (
    request: Request,
    context: GetDynamicDataContext<PATH>,
) => Promise<DataResult<DATA>> | DataResult<DATA>;

export type GetContent<
    PATH extends Record<string, string> = Record<string, string>,
    DATA = unknown,
> = (
    params: GetContentParams<PATH, DATA>,
) => Promise<string> | string;

export type Handlers<
    PATH extends Record<string, string> = Record<string, string>,
    DATA = unknown,
> = Partial<
    Record<
        'POST' | 'PUT' | 'PATCH' | 'DELETE',
        GetDynamicData<PATH, DATA>
    >
>;

type BasePageDescriptor<
    PATH extends Record<string, string> = Record<string, string>,
    DATA = unknown,
> = {
    /** The url (in your codebase) of the descriptor. Unless you know what you
     * are doing, it should always be `new URL(import.meta.url)` */
    self: URL;

    /**
     * The url pattern of the descriptor, that will be used to generate the url
     * of each page. Uses the syntax of `path-to-regexp`.
     */
    pattern: string;

    /**
     * Function returning the page content as a string for a given data object.
     */
    getContent: GetContent<PATH, DATA>;

    /**
     * Dictionnary of function dynamically generating a data object in response to
     * a POST, PUT, PATCH or DELETE
     */
    handlers?: Handlers<PATH, DATA>;
};
export type DynamicPageDescriptor<
    PATH extends Record<string, string> = Record<string, string>,
    DATA = unknown,
> = BasePageDescriptor<PATH, DATA> & {
    /**
     * function returning a data object for a given path object and a
     * generation request.
     *
     * This method will only be called if you use a server. For dynamic
     * pages, this method will be called on each requests. For static pages,
     * this method will be called for each non `GET` requests. This method
     * will return an empty data object if not defined.
     */
    getDynamicData: GetDynamicData<PATH, DATA>;
};

export type StaticPageDescriptor<
    PATH extends Record<string, string> = Record<
        string,
        string
    >,
    DATA = unknown,
> = BasePageDescriptor<PATH, DATA> & {
    /**
     * A function returning the list of all path object (matching the `pattern`)
     * that will be used to generate each page.
     *
     * If not defined, this method will return an empty array by default.
     */
    getPathList?: GetPathList<PATH>;

    /**
     * function returning a data object for a given path object.
     *
     * If not defined, this method will return an empty data object if not
     * defined.
     */
    getStaticData?: GetStaticData<PATH, DATA>;
};

export type PageDescriptor<
    PATH extends Record<string, string> = Record<
        string,
        string
    >,
    DATA = unknown,
> = StaticPageDescriptor<PATH, DATA> | DynamicPageDescriptor<PATH, DATA>;

const handlers = zod.object({
    'POST': zod.optional(zod.function(zod.tuple([]), zod.any(), {
        invalid_type_error:
            'Expected a page descriptor with a POST handler as a function',
    })),
    'PUT': zod.optional(zod.function(zod.tuple([]), zod.any(), {
        invalid_type_error:
            'Expected a page descriptor with a PUT handler as a function',
    })),
    'PATCH': zod.optional(zod.function(zod.tuple([]), zod.any(), {
        invalid_type_error:
            'Expected a page descriptor with a PATCH handler as a function',
    })),
    'DELETE': zod.optional(zod.function(zod.tuple([]), zod.any(), {
        invalid_type_error:
            'Expected a page descriptor with a DELETE handler as a function',
    })),
}, {
    invalid_type_error:
        'Expected a page descriptor with "handlers" as an object',
});

const baseDescriptorSchema = zod.object({
    pattern: zod.string({
        required_error: 'A page descriptor must have a string "pattern"',
        invalid_type_error:
            'Expected a page descriptor with "pattern" as a string',
    }),
    self: zod.instanceof(URL, {
        message: 'A page descriptor must have a URL "self"',
    }),
    getContent: zod.function(zod.tuple([]), zod.any(), {
        required_error: 'A page descriptor must have a function "getContent"',
        invalid_type_error:
            'Expected a page descriptor with "getContent" as a function',
    }),
    handlers: zod.optional(handlers),
}, {
    invalid_type_error: 'Expected a page descriptor object',
});

const dynamicDescriptorSchema: zod.Schema<DynamicPageDescriptor> =
    baseDescriptorSchema.extend({
        getDynamicData: zod.function(zod.tuple([]), zod.any(), {
            required_error:
                'A dynamic page descriptor must have a function "getDynamicData"',
            invalid_type_error:
                'Expected a dynamic page descriptor with "getDynamicData" as a function',
        }),
    });

const staticDescriptorSchema: zod.Schema<StaticPageDescriptor> =
    baseDescriptorSchema.extend({
        getPathList: zod.optional(zod.function(zod.tuple([]), zod.any(), {
            invalid_type_error:
                'Expected a static page descriptor with "getPathList" as a function',
        })),
        getStaticData: zod.optional(zod.function(zod.tuple([]), zod.any(), {
            invalid_type_error:
                'Expected a static page descriptor with "getStaticData" as a function',
        })),
    });

type ValidationResult<T> = { success: true; data: T } | {
    success: false;
    error: string;
};

function parseStaticDescriptor<
    PATH extends Record<string, string> = Record<
        string,
        string
    >,
    DATA = unknown,
>(descriptor: unknown): ValidationResult<StaticPageDescriptor<PATH, DATA>> {
    const result = staticDescriptorSchema.safeParse(descriptor);
    if (!result.success) {
        return { success: false, error: result.error.errors[0].message };
    }
    return {
        success: true,
        data: result.data as StaticPageDescriptor<PATH, DATA>,
    };
}

function parseDynamicDescriptor<
    PATH extends Record<string, string> = Record<
        string,
        string
    >,
    DATA = unknown,
>(descriptor: unknown): ValidationResult<DynamicPageDescriptor<PATH, DATA>> {
    const result = dynamicDescriptorSchema.safeParse(descriptor);
    if (!result.success) {
        return { success: false, error: result.error.errors[0].message };
    }
    return {
        success: true,
        data: result.data as DynamicPageDescriptor<PATH, DATA>,
    };
}

/**
 * Build a page object from a page descriptor
 */
export function page<
    PATH extends Record<string, string> = Record<string, string>,
    DATA = unknown,
>(
    descriptor: PageDescriptor<PATH, DATA>,
): Page {
    if (
        typeof descriptor === 'object' && descriptor !== null &&
        'getDynamicData' in descriptor
    ) {
        const result = parseDynamicDescriptor(descriptor);
        if (result.success) {
            return new DynamicPage<PATH, DATA>(descriptor) as unknown as Page;
        } else {
            logger().error({
                descriptor,
                msg() {
                    return `Error while parsing descriptor ${
                        descriptor.pattern ?? descriptor.self.href ??
                            'unknown'
                    }: ${result.error}`;
                },
            });
            Deno.exit();
        }
    }

    const result = parseStaticDescriptor(descriptor);
    if (result.success) {
        return new StaticPage<PATH, DATA>(descriptor) as unknown as Page;
    } else {
        logger().error({
            descriptor,
            msg() {
                return `Error while parsing descriptor ${
                    descriptor.pattern ?? descriptor.self.href ??
                        'unknown'
                }: ${result.error}`;
            },
        });
        Deno.exit();
    }
}

export type Page<
    PATH extends Record<string, string> = Record<string, string>,
    DATA = unknown,
> =
    | StaticPage<PATH, DATA>
    | DynamicPage<PATH, DATA>;

class BasePage<
    PATH extends Record<string, string> = Record<string, string>,
    DATA = unknown,
    DESCRIPTOR extends PageDescriptor<PATH, DATA> = PageDescriptor<PATH, DATA>,
> {
    #descriptor: DESCRIPTOR;
    #urlCompiler: pathToRegexp.PathFunction<PATH>;
    #urlMatcher: pathToRegexp.MatchFunction<PATH>;

    constructor(
        descriptor: DESCRIPTOR,
    ) {
        this.#descriptor = descriptor;
        this.#urlCompiler = pathToRegexp.compile(this.#descriptor.pattern);
        this.#urlMatcher = pathToRegexp.match(this.#descriptor.pattern);
    }

    get pattern() {
        return this.#descriptor.pattern;
    }

    get self() {
        return this.#descriptor.self;
    }

    get handlers(): Record<string, GetDynamicData<PATH, DATA> | undefined> {
        return this.#descriptor.handlers ?? {};
    }

    getContent(params: GetContentParams<PATH, DATA>) {
        return this.#descriptor.getContent(params);
    }

    compile(path: PATH) {
        try {
            return this.#urlCompiler(path);
            // deno-lint-ignore no-explicit-any
        } catch (error: any) {
            throw new PageDescriptorError(
                `Error while compiling pattern "${this.pattern}" with path "${
                    JSON.stringify(path)
                }": ${error.message}`,
                this,
            );
        }
    }

    match(path: string) {
        return this.#urlMatcher(path);
    }
}

export class DynamicPage<
    PATH extends Record<string, string> = Record<string, string>,
    DATA = unknown,
    DESCRIPTOR extends DynamicPageDescriptor<PATH, DATA> =
        DynamicPageDescriptor<PATH, DATA>,
> extends BasePage<PATH, DATA, DESCRIPTOR> {
    #descriptor: DESCRIPTOR;

    constructor(
        descriptor: DESCRIPTOR,
    ) {
        super(descriptor);
        this.#descriptor = descriptor;
    }

    getDynamicData(request: Request, context: GetDynamicDataContext<PATH>) {
        if (this.#descriptor.getDynamicData === undefined) {
            return { data: {} } as DataResult<DATA>;
        }

        return this.#descriptor.getDynamicData(request, context);
    }
}

export class StaticPage<
    PATH extends Record<string, string> = Record<string, string>,
    DATA = unknown,
    DESCRIPTOR extends StaticPageDescriptor<PATH, DATA> = StaticPageDescriptor<
        PATH,
        DATA
    >,
> extends BasePage<PATH, DATA, DESCRIPTOR> {
    #descriptor: StaticPageDescriptor<PATH, DATA>;

    constructor(
        descriptor: DESCRIPTOR,
    ) {
        super(descriptor);
        this.#descriptor = descriptor;
    }

    getStaticData(context: GetStaticDataContext<PATH>) {
        if (this.#descriptor.getStaticData === undefined) {
            return { data: {} } as DataResult<DATA>;
        }
        return this.#descriptor.getStaticData(context);
    }

    getPathList(params: GetPathListParams) {
        if (this.#descriptor.getPathList === undefined) {
            return [{} as PATH];
        }
        return this.#descriptor.getPathList(params);
    }
}

export class PageDescriptorError extends FrugalError {
    // deno-lint-ignore no-explicit-any
    page: BasePage<any, any, any>;

    // deno-lint-ignore no-explicit-any
    constructor(message: string, page: BasePage<any, any, any>) {
        super(message);
        this.page = page;
    }
}
