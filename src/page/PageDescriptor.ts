import * as zod from '../../dep/zod.ts';

import { PathObject } from './PathObject.ts';
import { DataResponse } from './FrugalResponse.ts';

/**
 * The different phases of Frugal.
 *
 * A page descriptor method can be called in a build phase (during the Frugal
 * instance build), during the refresh phase (at runtime in a refresh call) or
 * during the generate phase (at runtime in a generate call).
 */
export type Phase = 'build' | 'refresh' | 'generate';

export interface GetPathListParams {
  /** The current phase (build, refresh or generate) */
  phase: Phase;

  resolve: (specifier: string) => string;
}

export interface StaticDataContext<PATH extends string = string> {
  /** The current phase (build, refresh or generate) */
  phase: Phase;

  /** The path for which we need the data */
  path: PathObject<PATH>;

  resolve: (specifier: string) => string;
}

export interface DynamicDataContext<PATH extends string = string>
  extends StaticDataContext<PATH> {
  /** a state object containing data passed from middlewares */
  state: Record<string, unknown>;

  /** the request object */
  request: Request;
}

// deno-lint-ignore no-explicit-any
export type Assets = Partial<Record<string, any>>;

export type GetContentContext<DATA = unknown, PATH extends string = string> = {
  /** the method of the request that caused the call to `getContent`  */
  method: string;

  /** The current phase (build, refresh or generate) */
  phase: Phase;

  /** The path object we need the content from */
  path: PathObject<PATH>;

  /** The data object we need the content from */
  data: DATA;

  /** The pathname of the page (the `pattern` of the descriptor compiled with the
   * path object) */
  pathname: string;

  /** The path of the descriptor */
  descriptor: string;

  /** The loader context (containing the assets generated by each loaders) */
  assets: Assets;
};

export type PathList<PATH extends string = string> = PathObject<PATH>[];

export type GetPathList<PATH extends string = string> = (
  params: GetPathListParams,
) => Promise<PathList<PATH>> | PathList<PATH>;

export type StaticHandler<DATA = unknown, PATH extends string = string> = (
  context: StaticDataContext<PATH>,
) => Promise<DataResponse<DATA>> | DataResponse<DATA>;

export type DynamicHandler<DATA = unknown, PATH extends string = string> = (
  context: DynamicDataContext<PATH>,
) => Promise<DataResponse<DATA>> | DataResponse<DATA>;

export type Handler<DATA = unknown, PATH extends string = string> =
  | StaticHandler<DATA, PATH>
  | DynamicHandler<DATA, PATH>;

export type GetContent<DATA = unknown, PATH extends string = string> = (
  context: GetContentContext<DATA, PATH>,
) => Promise<string> | string;

interface BasePageDescriptor<DATA = unknown, PATH extends string = string> {
  /** The url (in your codebase) of the descriptor. Unless you know what you
   * are doing, it should always be `new URL(import.meta.url)` */
  self: string;

  /**
   * The url pattern of the descriptor, that will be used to generate the url
   * of each page. Uses the syntax of `path-to-regexp`.
   */
  pattern: string;

  /**
   * Function returning the page content as a string for a given data object.
   */
  getContent: GetContent<DATA, PATH>;

  POST?: DynamicHandler<DATA, PATH>;
  PUT?: DynamicHandler<DATA, PATH>;
  DELETE?: DynamicHandler<DATA, PATH>;
  PATCH?: DynamicHandler<DATA, PATH>;
}

export interface DynamicPageDescriptor<
  DATA = unknown,
  PATH extends string = string,
> extends BasePageDescriptor<DATA, PATH> {
  type: 'dynamic';
  /**
   * function returning a data object for a given path object and a generation
   * request.
   *
   * This method will only be called if you use a server. This will be called
   * on each requests. This method will return an empty data object if not
   * defined.
   */
  GET: DynamicHandler<DATA, PATH>;
}

export interface StaticPageDescriptor<
  DATA = unknown,
  PATH extends string = string,
> extends BasePageDescriptor<DATA, PATH> {
  /**
   * A function returning the list of all path object (matching the `pattern`)
   * that will be used to generate each page.
   *
   * If not defined, this method will return an empty array by default.
   */
  getPathList?: GetPathList<PATH>;

  /**
   * function returning a data object for a given path object.
   *
   * If not defined, this method will return an empty data object if not
   * defined.
   */
  GET?: StaticHandler<DATA, PATH>;
}

export type PageDescriptor<
  DATA = unknown,
  PATH extends string = string,
> = StaticPageDescriptor<DATA, PATH> | DynamicPageDescriptor<DATA, PATH>;

const baseDescriptorSchema = zod.object({
  pattern: zod.string({
    required_error: 'A page descriptor must have a string "pattern"',
    invalid_type_error: 'Expected a page descriptor with "pattern" as a string',
  }),
  self: zod.string({
    required_error: 'A page descriptor must have a string "self"',
    invalid_type_error: 'Expected a page descriptor with "self" as a string',
  }),
  getContent: zod.function(zod.tuple([]), zod.any(), {
    required_error: 'A page descriptor must have a function "getContent"',
    invalid_type_error:
      'Expected a page descriptor with "getContent" as a function',
  }),
  POST: zod.optional(zod.function(zod.tuple([]), zod.any(), {
    invalid_type_error: 'Expected a page descriptor with "POST" as a function',
  })),
  PUT: zod.optional(zod.function(zod.tuple([]), zod.any(), {
    invalid_type_error: 'Expected a page descriptor with "PUT" as a function',
  })),
  PATCH: zod.optional(zod.function(zod.tuple([]), zod.any(), {
    invalid_type_error: 'Expected a page descriptor with "PATCH" as a function',
  })),
  DELETE: zod.optional(zod.function(zod.tuple([]), zod.any(), {
    invalid_type_error:
      'Expected a page descriptor with "DELETE" as a function',
  })),
  OPTIONS: zod.optional(zod.function(zod.tuple([]), zod.any(), {
    invalid_type_error:
      'Expected a page descriptor with "OPTIONS" as a function',
  })),
  HEAD: zod.optional(zod.function(zod.tuple([]), zod.any(), {
    invalid_type_error:
      'Expected a page descriptor with "OPTIONS" as a function',
  })),
}, {
  invalid_type_error: 'Expected a page descriptor object',
});

const dynamicDescriptorSchema: zod.Schema<DynamicPageDescriptor> =
  baseDescriptorSchema.extend({
    type: zod.literal('dynamic', {
      required_error: 'A dynamic page descriptor must have a string "type"',
      invalid_type_error:
        'Expected a dynamic page descriptor with "type" as "dynamic"',
    }),
    GET: zod.function(zod.tuple([]), zod.any(), {
      required_error: 'A dynamic page descriptor must have a function "GET"',
      invalid_type_error:
        'Expected a dynamic page descriptor with "GET" as a function',
    }),
  });

const staticDescriptorSchema: zod.Schema<StaticPageDescriptor> =
  baseDescriptorSchema.extend({
    getPathList: zod.optional(zod.function(zod.tuple([]), zod.any(), {
      invalid_type_error:
        'Expected a static page descriptor with "getPathList" as a function',
    })),
    GET: zod.optional(zod.function(zod.tuple([]), zod.any(), {
      invalid_type_error:
        'Expected a static page descriptor with "GET" as a function',
    })),
  });

type ValidationResult<T> = { success: true; data: T } | {
  success: false;
  error: string;
};

export function parseStaticDescriptor<
  DATA = unknown,
  PATH extends string = string,
>(descriptor: unknown): ValidationResult<StaticPageDescriptor<DATA, PATH>> {
  const result = staticDescriptorSchema.safeParse(descriptor);
  if (!result.success) {
    return { success: false, error: result.error.errors[0].message };
  }
  return {
    success: true,
    data: result.data as StaticPageDescriptor<DATA, PATH>,
  };
}

export function parseDynamicDescriptor<
  DATA = unknown,
  PATH extends string = string,
>(descriptor: unknown): ValidationResult<DynamicPageDescriptor<DATA, PATH>> {
  const result = dynamicDescriptorSchema.safeParse(descriptor);
  if (!result.success) {
    return { success: false, error: result.error.errors[0].message };
  }
  return {
    success: true,
    data: result.data as DynamicPageDescriptor<DATA, PATH>,
  };
}
